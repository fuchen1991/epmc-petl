options
{
  JDK_VERSION = "1.8";
  LOOKAHEAD = 1;
  STATIC = false;
}
PARSER_BEGIN(SpotParser)package epmc.automaton;

import epmc.util.BitSet;
import epmc.util.BitSetUnboundedLongArray;
import java.util.Map;
import epmc.automaton.ProblemsAutomaton;
import static epmc.error.UtilError.ensure;
import epmc.error.EPMCException;
import epmc.expression.Expression;
import epmc.expression.standard.ExpressionOperator;
import epmc.expression.standard.ExpressionLiteral;
import epmc.operator.OperatorOr;
import epmc.operator.OperatorAnd;
import epmc.operator.OperatorNot;
import epmc.graph.explicit.GraphExplicitWrapper;

public class SpotParser {

  public GraphExplicitWrapper parseAutomaton(Map<String,Expression> ap2expr)
       {
    assert ap2expr != null;
    try {
      return Automaton(ap2expr);
    } catch (ParseException e) {
      ensure(false, ProblemsAutomaton.LTL2BA_SPOT_PROBLEM_PARSE, e);
      return null;
    }
  }

  private Expression and(Expression a, Expression b) {
      return new ExpressionOperator.Builder()
      	.setOperator(OperatorAnd.AND)
      	.setOperands(a, b)
      	.build();
  }

    private Expression or(Expression a, Expression b) {
        return new ExpressionOperator.Builder()
            .setOperator(OperatorOr.OR)
            .setOperands(a, b)
            .build();
    }

    private Expression not(Expression expression) {
    	return new ExpressionOperator.Builder()
        	.setOperator(OperatorNot.NOT)
        	.setOperands(expression)
        	.build();
    }
}PARSER_END(SpotParser)SKIP :{  " "| "\r"| "\t"| "\n"
}TOKEN :{  < COMMA : "," >
| < COLON : ":" >
| < EQUALS : "=" >
| < NOT : "!" >
| < AND : "&" >
| < OR : "|" >
| < LPARENTH : "(" >
| < RPARENTH : ")" >
| < LBRACK : "[" >
| < RBRACK : "]" >
| < LCURLY : "{" >
| < RCURLY : "}" >
| < QUOTE : "\"" >| < ACC : "acc" >
| < HOA : "HOA" >
| < V1 : "v1" >
| < NAME : "name" >
| < STATES : "States" >
| < START : "Start" >
| < AP : "AP" >
| < ACC_NAME : "acc-name" >
| < GENERALIZED_BUCHI : "generalized-Buchi" >
| < BUCHI : "Buchi" >
| < ALL : "all" >
| < ACCEPTANCE : "Acceptance" >
| < INF : "Inf" >
| < PROPERTIES : "properties" >
| < TRANS_LABELS : "trans-labels" >
| < EXPLICIT_LABELS : "explicit-labels" >
| < TRANS_ACC : "trans-acc" >
| < STATE_ACC : "state-acc" >
| < STUTTER_INVARIANT : "stutter-invariant" >
| < DETERMINISTIC : "deterministic" >
| < INHERENTLY_WEAK : "inherently-weak" >
| < COMPLETE : "complete" >
| < TERMINAL : "terminal" >
| < BODY : "--BODY--" >
| < END : "--END--" >
| < STATE : "State" >
| < T : "t" >
| < NUM_INT : (["1"-"9"](["0"-"9"])*)|("0") >
| < IDENTIFIER : (["a"-"z","A"-"Z","0"-"9","_"])+ >
}GraphExplicitWrapper Automaton(Map<String,Expression> ap2expr)  :{
  HanoiHeader header;
  GraphExplicitWrapper graph;
}{
  header = Header(ap2expr)
  graph = Body(header)
  { return graph; }
}

HanoiHeader Header(Map<String,Expression> ap2expr) :
{
  HanoiHeader header = new HanoiHeader(ap2expr);
  int numStates;
  int startState;
  Token ap;
  int numAccs;
}
{
(  <HOA> <COLON> <V1>
| <NAME> <COLON> Identifiers()
| <STATES> <COLON> numStates = parseInt() { header.setNumStates(numStates); }
| <START> <COLON> startState = parseInt() { header.setStartState(startState); }
| <AP> <COLON> parseInt() ( <QUOTE> ap = <IDENTIFIER> <QUOTE> { header.addAP(ap.toString()); } )*
| <ACC_NAME> <COLON> (
    <BUCHI>  { header.setNumAcc(1); }
  | <GENERALIZED_BUCHI > numAccs = parseInt() { header.setNumAcc(numAccs); }
  | <ALL> { header.setNumAcc(0); }
)
| <ACCEPTANCE> <COLON> parseInt()
  ( 
  <INF> <LPARENTH> parseInt() <RPARENTH> (<AND> <INF> <LPARENTH>parseInt()<RPARENTH> )*
  | <T>
  )
| <PROPERTIES> <COLON> (<TRANS_LABELS> | <EXPLICIT_LABELS> | <TRANS_ACC> | <STUTTER_INVARIANT> | <DETERMINISTIC> | <STATE_ACC> | <INHERENTLY_WEAK> | <COMPLETE> | <TERMINAL>)*
)*
  { return header; }
}

GraphExplicitWrapper Body(HanoiHeader header)  :
{
  GraphPreparator graph = new GraphPreparator(header);
}
{
  <BODY>
  (State(graph))*
  <END>
  { return graph.toGraph(); }
}

void State(GraphPreparator graph)  :
{
  int from;
  Expression guard;
  int to;
  BitSet acc;
  int accState;
}
{
  <STATE> <COLON> from = parseInt()
  (	<LBRACK>guard = Guard(graph.getHeader())<RBRACK> to = parseInt()
	{ acc = new BitSetUnboundedLongArray(); }
	(<LCURLY> (accState = parseInt() { acc.set(accState); })* <RCURLY>)?
	{ graph.addTransition(from, to, guard, acc); }
  )*
}

String Identifier() :
{
  Token literal;
  String result;
}
{
  ((literal = <IDENTIFIER> { result = literal.toString(); })
  | (<QUOTE> literal = <IDENTIFIER> { result = literal.toString(); } <QUOTE>))
  { return result; }
}

String Identifiers() :
{
  Token literal;
  String result = "";
}
{
  <QUOTE>
    (
      literal = <IDENTIFIER> { result += literal.toString(); }
      | literal = <AND> { result += literal.toString(); }
      | literal = <OR> { result += literal.toString(); }
      | literal = <NOT> { result += literal.toString(); }
      | literal = <LPARENTH> { result += literal.toString(); }
      | literal = <RPARENTH> { result += literal.toString(); }
      | literal = <NUM_INT> { result += literal.toString(); }
    )*
    <QUOTE>
  { return result; }
}

Expression Guard(HanoiHeader header) :
{
  Expression expr;
}
{
  expr = ExpressionOr(header)
  { return expr; }
}

Expression ExpressionOr(HanoiHeader header) :
{
  Expression p;
  Expression nextProp;
}
{
  p = ExpressionAnd(header)
  (
    <OR> nextProp = ExpressionAnd(header)
    { p = or(p, nextProp); }
  )*
  { return p; }
}

Expression ExpressionAnd(HanoiHeader header) :
{
  Expression p;
  Expression nextProp;
}
{
  p = ExpressionNot(header)
  (
    <AND>
    nextProp = ExpressionNot(header)
    { p = and(p, nextProp); }
  )*
  { return p; }
}

Expression ExpressionNot(HanoiHeader header) :
{
  Expression p;
}
{
  (
    <NOT>
    p = ExpressionNot(header)
    { p = not(p); }
  | <LPARENTH> p = ExpressionOr(header) <RPARENTH>
  | p = ExpressionTrue(header)
  | p = ExpressionIdentifier(header)
  )
  { return p; }
}

Expression ExpressionTrue(HanoiHeader header) :
{
  Token literal;
}
{
  <T> { return ExpressionLiteral.getTrue(); }
}

Expression ExpressionIdentifier(HanoiHeader header) :
{
  int id;
}
{
  id = parseInt()
  {
    return header.numberToIdentifier(id);
  }
}

private int parseInt() :
{
	Token intg;
}
{
	intg = <NUM_INT>
	{ return Integer.parseInt(intg.toString()); }
}
